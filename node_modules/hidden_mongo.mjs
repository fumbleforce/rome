import { MongoClient, ObjectID } from "mongodb";
import {
  sendDataSet,
  registerService,
  socketMethod,
  settings,
  onDisconnection,
  sendDataUpdate
} from "hidden_server";

const {
  MONGO_URL = "mongodb://localhost:27017",
  MONGO_DB = "hidden",
} = settings;

const collections = {};
const subcriptions = {};
const collectionStartupQueue = [];

const mongo = {
  collections
};


async function getMongoDBConnection (url, dbName) {
  console.log("[hidden] <mongo> Connecting to", url, dbName);
  // Use connect method to connect to the server
  const client = await MongoClient.connect(url, {
    useNewUrlParser: true,
    useUnifiedTopology: true
  });

  const db = client.db(dbName);

  return db;
}

async function getConnection () {
  if (mongo.db) return mongo.db;

  // Use connect method to connect to the server
  mongo.db = await getMongoDBConnection(MONGO_URL, MONGO_DB);

  return mongo.db;
}

function transformQuery (query) {
  if (typeof(query) === "string") {
    return { _id: query };
  }

  return query;
}

function subscribe (socket, queryMethods, name, _id) {
  const key = `${name}::${_id}`;

  console.log("[hidden] <mongo> subscribe", socket.id, key, _id);

  if (subcriptions[key]) {
    return subcriptions[key].subs.push(socket.id);
  }

  const cursor = queryMethods.watch([
    { $match: {} }
  ]);

  cursor.on("change", args => {
    const {
      updateDescription = {},
    } = args;

    sendDataUpdate(name, _id, updateDescription.updatedFields);
  });

  subcriptions[key] = {
    subs: [socket.id],
    cursor,
  };
}

function unsubscribe (socket, key) {
  const subData = subcriptions[key];

  if (!subData) return;

  const id = socket.id;
  const { cursor, subs } = subData;
  const index = subs.indexOf(id);

  if (index === -1) return;

  subs.splice(index, 1);

  if (!subs.length) {
    cursor.close();
    delete subData[cursor];
  }
}

function makeCollectionModel (model) {
  const {
    name,
    opts: {
      transformFindOne
    }
  } = model;

  const collection = mongo.db.collection(name);

  console.log("[hidden] <mongo> Making collection", name);

  const queryMethods = {
    collection,

    async findOne (query) {
      const result = await queryMethods._findOne(query);
      return transformFindOne ? transformFindOne(result) : result;
    },

    _findOne (query) {
      const q = transformQuery(query);
      console.log("[hidden] <mongo> findOne", name, q);
      return collection.findOne(q);
    },

    find (query) {
      const q = transformQuery(query);
      console.log("[hidden] <mongo> find", name, q);
      return collection.find(q);
    },

    count (query) {
      const q = transformQuery(query);
      console.log("[hidden] <mongo> count", name, q);
      return collection.find(q).count();
    },

    async insertOne (data, ...args) {
      data._id = new ObjectID().toHexString();
      console.log("[hidden] <mongo> insertOne", name, data);
      const { insertedId: _id } = await collection.insertOne(data, ...args);
      return _id;
    },

    async updateOne (query, ...args) {
      const q = transformQuery(query);
      console.log("[hidden] <mongo> updateOne", name, q, ...args);
      const updateResult = await collection.updateOne(q, ...args);
      const updatedDoc = await collection.findOne(q);

      sendDataSet(name, updatedDoc._id, updatedDoc);

      return updateResult
    },

    updateMany (query, ...args) {
      const q = transformQuery(query);
      console.log("[hidden] <mongo> updateMany", name, q, ...args);
      return collection.updateMany(q, ...args);
    },

    deleteOne (query) {
      const q = transformQuery(query);
      console.log("[hidden] <mongo> deleteOne", name, q);
      return collection.deleteOne(q);
    },

    deleteMany (query) {
      const q = transformQuery(query)
      console.log("[hidden] <mongo> deleteMany", name, q);
      return collection.deleteMany(q);
    },

    watch (pipeline) {
      console.log("[hidden] <mongo> watching", name, pipeline);
      return collection.watch(pipeline);
    },

    async sub (socket, name, _id) {
      const doc = await queryMethods.findOne(_id);

      socket.sub(name, _id, doc);
      subscribe(socket, queryMethods, name, _id);
    },

    async unsub (socket, name, _id) {
      socket.unsub(name, _id);
      const key = `${name}::${_id}`;
      unsubscribe(socket, key);
    },
  };

  Object.assign(model, queryMethods);

  return model;
}

export function collection (name, opts = {}) {
  const model = { name, opts };
  collections[name] = model;

  if (mongo.db) {
    makeCollectionModel(model);
  } else {
    console.log("[hidden] <mongo> Queuing collection", name);
    collectionStartupQueue.push(name);
  }

  return collections[name];
}

onDisconnection(socket => {
  const id = socket.id;

  Object.keys(subcriptions).forEach(key => {
    unsubscribe(socket, key);
  });
});

registerService("mongo", async () => {
  await getConnection();

  collectionStartupQueue.forEach(name => makeCollectionModel(collections[name]));
});