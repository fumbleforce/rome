import { MongoClient, ObjectID } from "mongodb";
import { sendDataSet, registerService, settings } from "hidden_server";

const {
  MONGO_URL = "mongodb://localhost:27017",
  MONGO_DB = "hidden",
} = settings;

const collections = {};
const collectionStartupQueue = [];

const mongo = {
  collections
};

async function getMongoDBConnection (url, dbName) {
  console.log("[hidden] <mongo> Connecting to", url, dbName);
  // Use connect method to connect to the server
  const client = await MongoClient.connect(url, {
    useNewUrlParser: true,
    useUnifiedTopology: true
  });

  const db = client.db(dbName);

  return db;
}

async function getConnection () {
  if (mongo.db) return mongo.db;

  // Use connect method to connect to the server
  mongo.db = await getMongoDBConnection(MONGO_URL, MONGO_DB);

  return mongo.db;
}

function transformQuery (query) {
  if (typeof(query) === "string") {
    return { _id: query };
  }

  return query;
}

function makeCollectionModel (model) {
  const {
    name,
    opts: {
      transformFindOne
    }
  } = model;

  const collection = mongo.db.collection(name);

  console.log("[hidden] <mongo> Making collection", name);

  const queryMethods = {
    collection,

    async findOne (query) {
      const result = await queryMethods._findOne(query);
      return transformFindOne ? transformFindOne(result) : result;
    },

    _findOne (query) {
      const q = transformQuery(query);
      console.log("[mongo] findOne", name, q);
      return collection.findOne(q);
    },

    find (query) {
      const q = transformQuery(query);
      console.log("[mongo] find", name, q);
      return collection.find(q);
    },

    count (query) {
      const q = transformQuery(query);
      console.log("[mongo] count", name, q);
      return collection.find(q).count();
    },

    async insertOne (data, ...args) {
      data._id = new ObjectID().toHexString();
      console.log("[mongo] insertOne", name, data);
      const { insertedId: _id } = await collection.insertOne(data, ...args);
      return _id;
    },

    async updateOne (query, ...args) {
      const q = transformQuery(query);
      console.log("[mongo] updateOne", name, q, ...args);
      const updateResult = await collection.updateOne(q, ...args);
      const updatedDoc = await collection.findOne(q);

      sendDataSet(name, updatedDoc._id, updatedDoc);

      return updateResult
    },

    updateMany (query, ...args) {
      const q = transformQuery(query);
      console.log("[mongo] updateMany", name, q, ...args);
      return collection.updateMany(q, ...args);
    },

    deleteOne (query) {
      const q = transformQuery(query);
      console.log("[mongo] deleteOne", name, q);
      return collection.deleteOne(q);
    },

    deleteMany (query) {
      const q = transformQuery(query)
      console.log("[mongo] deleteMany", name, q);
      return collection.deleteMany(q);
    },

    watch (pipeline) {
      return collection.watch(pipeline);
    }
  };

  Object.assign(model, queryMethods);

  return model;
}

export function collection (name, opts = {}) {
  const model = { name, opts };
  collections[name] = model;

  if (mongo.db) {
    makeCollectionModel(model);
  } else {
    console.log("[hidden] <mongo> Queuing collection", name);
    collectionStartupQueue.push(name);
  }

  return collections[name];
}

registerService("mongo", async () => {
  await getConnection();

  collectionStartupQueue.forEach(name => makeCollectionModel(collections[name]));
});