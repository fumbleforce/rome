import fs from "fs";
import sirv from "sirv";
import Polka from "polka";
import io from "socket.io";
import redis from "socket.io-redis";
import compression from "compression";

const { PORT = 4000 } = process.env;
const __dirname = fs.realpathSync(".");

export class IntentionalError extends Error {
  constructor(message) {
    super(message);
    this.name = `IntentionalError: ${message}`;
  }
}

const getFile = pathName => {
  const path = `${__dirname}/${pathName}`;

  try {
    return fs.readFileSync(path, "utf-8");
  } catch (e) {
    console.warn("File not found", path);
  }

  return null;
}

const getJSONFile = pathName => {
  const file = getFile(pathName);
  if (file == null) return null;
  return JSON.parse(file);
}

export const settings = {
  DEBUG: false,
};

const settingsFile = getJSONFile("../settings.json");

Object.assign(settings, settingsFile);

const {
  DEBUG
} = settings;

console.log("[hidden] settings", settingsFile ? "custom" : "default", settings);

const template = getFile("./public/index.html");

function HTMLRenderer (req, res, next) {
  res.renderHTMLFile = htmlFile => {
    try {
      res.setHeader("content-type", "text/html");
      res.end(htmlFile);
    } catch (err) {
      console.error(err);
      return res.end(err.message || err);
    }
  };
  next();
};

function startHTTPServer () {
  const serve = sirv("./public", { dev: DEBUG });
  const compress = compression({ threshold: 0 });

  const polka = Polka()
    .use(compress, serve, HTMLRenderer)
    .get("/", (req, res) => res.renderHTMLFile(template))
    .listen(PORT, err => {
      if (err) console.error("error", err);
      else console.log("Started server:", `localhost:${PORT}`);
    });

  const server = polka.server;

  return server;
};


let sockets;
let started = false;
const services = {};
const methodStore = {};
const onConnectionStore = [];
const onDisconnectionStore = [];
const startupScripts = [];

const onRequest = socket => (name, handler) => {
  socket.on(name, async (responseId, ...args) => {
    console.log(`[${name}] >`, ...args);

    try {
      const handlerResponse = handler(socket, ...args);

      const response = (handlerResponse instanceof Promise)
        ? (await handlerResponse)
        : handlerResponse;

      console.log(`[${name}] <`, response);

      socket.emit("response", responseId, null, response);
    } catch (err) {
      console.error(`[${name}] < error`, responseId, (err instanceof IntentionalError)
        ? err.message
        : err);
      return socket.emit("response", responseId, (err instanceof IntentionalError)
        ? err.message
        : 500);
    }
  });
};

function ensureStartup () {
  if (!started) throw new Error("Start Hidden server by using Hidden.start()");
}

function start () {
  const server = startHTTPServer();
  sockets = io(server, { wsEngine: "ws" });
  sockets.adapter(redis({ host: 'localhost', port: 6379 }));

  sockets.on("connection", socket => {
    console.log("[connection]", socket.id);
    socket.onRequest = onRequest(socket);

    Object.entries(methodStore).forEach(([name, func]) => {
      console.log(socket.id, name);
      socket.onRequest(name, func);
    });

    socket.on("event", console.warn);

    socket.sub = function (name, id) {
      return socket.join(`${name}::${id}`);
    }

    socket.set = function (name, doc, setLocally) {
      if (setLocally) {
        socket[name] = doc;
      }

      return socket.emit(`${name}::set`, doc);
    }

    socket.update = function (name, change, setLocally) {
      if (setLocally) {
        socket[name] = { ...socket[name], ...change };
      }

      return socket.emit(`${name}::update`, change);
    }

    onConnectionStore.forEach(cb => cb(socket));
  });

  sockets.on("disconnect", (socket) => {
    console.log("[disconnected]", socket.id);
    onDisconnectionStore.forEach(cb => cb(socket));
  });
}

export function method (key, func) {
  console.log("[method registered]", key);
  methodStore[key] = func;
  return func;
}

export function methods (methodObj) {
  return Object.fromEntries(
    Object.entries(methodObj).map(([key, func]) => [
      key,
      method(key, func)
    ])
  );
}

export function onConnection (cb) {
  onConnectionStore.push(cb);
}

export function onDisconnection (cb) {
  onDisconnectionStore.push(cb);
}

export function sendDataUpdate (name, id, change) {
  ensureStartup();

  const room = `${name}::${id}`;
  const channel = `${name}::update`;

  sockets.to(room).emit(channel, change);
}

export function sendDataSet (name, id, doc) {
  ensureStartup();

  const room = `${name}::${id}`;
  const channel = `${name}::set`;

  sockets.to(room).emit(channel, doc);
}

export function startup (cb) {
  if (started) cb();
  else startupScripts.push(cb);
}

export async function registerService (name, startup) {
  console.log("[hidden] Registered", name);
  services[name] = false;

  await startup();
  console.log("[hidden] Service finished", name);

  services[name] = true;

  let allStarted = true;

  Object.entries(services).forEach(([name, s]) => {
    if (!s) {
      allStarted = false;
      return false;
    }
  });

  if (allStarted) {
    console.log("[hidden] Startup finished");
    started = true;
    startupScripts.forEach(cb => cb());
  }
}

start();

export default {
  Error: IntentionalError,
  settings,
  startup,
  registerService,
  onConnection,
  onDisconnection,
  method,
  methods,
  sendDataUpdate,
  sendDataSet,
};
